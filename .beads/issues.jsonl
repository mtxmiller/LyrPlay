{"id":"LMS_StreamTest-139","title":"Phase 5: Implement Sync Group Persistence","description":"Parse 10-byte sync group ID from serv packet. Store in UserDefaults and include in HELO reconnects. Files: SlimProtoCoordinator.swift, SettingsManager.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:32:50.939972-05:00","updated_at":"2025-12-01T20:53:31.020556-05:00","closed_at":"2025-12-01T20:53:31.020556-05:00","dependencies":[{"issue_id":"LMS_StreamTest-139","depends_on_id":"LMS_StreamTest-87x","type":"blocks","created_at":"2025-12-01T20:33:02.998259-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-1us","title":"Phase 7.1: Study StreamDecoder Architecture","description":"Understand current push stream implementation. Read StreamDecoder.swift to understand: 1) How push streams buffer data, 2) BASS_StreamPutData usage, 3) Playback start/pause mechanics, 4) Current buffer management. Document findings for sync integration planning. Files: StreamDecoder.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:56:39.162135-05:00","updated_at":"2025-12-01T20:58:29.084918-05:00","closed_at":"2025-12-01T20:58:29.084918-05:00"}
{"id":"LMS_StreamTest-244","title":"Phase 2: Implement strm 'u' Unpause with Timing","description":"Parse strm 'u' command and extract jiffies from replay_gain field. Route to AudioPlayer.startAt() for delayed start or immediate resume. Files: SlimProtoCommandHandler.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:32:50.606929-05:00","updated_at":"2025-12-01T20:40:03.54217-05:00","closed_at":"2025-12-01T20:40:03.54217-05:00","dependencies":[{"issue_id":"LMS_StreamTest-244","depends_on_id":"LMS_StreamTest-5uz","type":"blocks","created_at":"2025-12-01T20:33:02.875434-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-3xu","title":"Phase 7: Implement Push Stream Synchronization Support","description":"CRITICAL: Extend StreamDecoder to support synchronized playback. LyrPlay uses ONLY push streams - URL stream sync (Phases 3-4) doesn't apply. Must implement: 1) Delayed start for push streams, 2) Timed pause (silence injection), 3) Skip ahead (buffer consumption). Files: StreamDecoder.swift, AudioManager.swift","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-01T20:56:17.555743-05:00","updated_at":"2025-12-01T20:56:17.555743-05:00","dependencies":[{"issue_id":"LMS_StreamTest-3xu","depends_on_id":"LMS_StreamTest-1us","type":"parent-child","created_at":"2025-12-01T20:56:47.913539-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-3xu","depends_on_id":"LMS_StreamTest-db0","type":"parent-child","created_at":"2025-12-01T20:56:47.947128-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-3xu","depends_on_id":"LMS_StreamTest-ceb","type":"parent-child","created_at":"2025-12-01T20:56:47.981631-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-3xu","depends_on_id":"LMS_StreamTest-77b","type":"parent-child","created_at":"2025-12-01T20:56:48.014706-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-3xu","depends_on_id":"LMS_StreamTest-512","type":"parent-child","created_at":"2025-12-01T20:56:48.047853-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-3xu","depends_on_id":"LMS_StreamTest-c4i","type":"parent-child","created_at":"2025-12-01T20:56:48.08128-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-3xu.1","title":"Phase 7.7: Implement STMl Buffer Ready Signaling","description":"Add STMl status message when buffer is ready for sync. Implementation: 1) Add sentSTMl flag to AudioStreamDecoder, 2) Check buffer level in decoder loop (2-3 seconds buffered), 3) Add delegate method audioStreamDecoderBufferReady(), 4) SlimProtoCoordinator sends STMl on callback, 5) Reset sentSTMl when starting new track. This tells server 'buffer loaded and ready for synchronized start'. Files: AudioStreamDecoder.swift, SlimProtoCoordinator.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T21:37:46.02853-05:00","updated_at":"2025-12-01T21:40:55.212523-05:00","closed_at":"2025-12-01T21:40:55.212523-05:00","dependencies":[{"issue_id":"LMS_StreamTest-3xu.1","depends_on_id":"LMS_StreamTest-3xu","type":"parent-child","created_at":"2025-12-01T21:37:46.028869-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-3xu.1","depends_on_id":"LMS_StreamTest-c4i","type":"blocks","created_at":"2025-12-01T21:37:46.029279-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-4ey","title":"CarPlay interface slow to load on connection","description":"When CarPlay connects, the Now Playing interface takes a long time to load and become responsive.\n\nSymptoms:\n- Significant delay when CarPlay first connects\n- Interface appears but may be unresponsive initially\n- Longer loading time than expected\n\nSuspected causes:\n- JSON-RPC commands blocking CarPlay UI initialization\n- Cover art loading/fetching delaying interface display\n- Synchronous operations on main thread during CarPlay connection\n- Heavy metadata queries during template setup\n\nImpact:\n- Poor user experience when connecting to CarPlay\n- Users must wait before interface becomes usable\n- Creates perception of app being slow/buggy\n\nFiles to investigate:\n- CarPlaySceneDelegate.swift (template setup and initialization)\n- NowPlayingManager.swift (metadata/artwork loading)\n- SlimProtoCoordinator.swift (JSON-RPC command timing)\n- AudioPlayer.swift (current state queries)\n\nOptimization opportunities:\n- Defer non-critical JSON-RPC queries until after template display\n- Use cached/placeholder artwork initially, load full resolution async\n- Move metadata fetching off main thread\n- Show template immediately with basic info, update details async\n- Batch JSON-RPC commands or make them truly asynchronous\n\nNext steps:\n- Profile CarPlay connection sequence with Instruments\n- Add timing logs to CarPlay template initialization\n- Identify blocking operations during connection\n- Test with/without artwork loading\n- Measure impact of JSON-RPC command timing\n\nPriority: P1 - Affects first impression and usability of CarPlay feature","notes":"## Resolution\n\nPhase 1 implementation was sufficient - no additional phases needed.\n\n### Changes Made\n- **Immediate template display**: Shows 'Resume Playback' + 'Loading...' instantly on CarPlay connect\n- **Parallel data fetching**: All 3 data sources (New Music, Random Releases, Playlists) fetched concurrently via DispatchGroup\n- **Progressive update**: Template updates smoothly when data arrives\n\n### Performance Improvement\n- Before: 4-6+ seconds before UI appeared (sequential blocking)\n- After: \u003c100ms to first UI, full content loads in background\n\n### Files Modified\n- CarPlaySceneDelegate.swift","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-03T21:37:46.314303-05:00","updated_at":"2025-12-06T11:27:41.889165-05:00","closed_at":"2025-12-06T11:27:41.889253-05:00"}
{"id":"LMS_StreamTest-512","title":"Phase 7.5: Update AudioManager Push Stream Routing","description":"Remove push stream fallback warnings and route to StreamDecoder sync methods. Update AudioManager.swift: 1) Remove 'Push streams don't support' error logs, 2) Route startAtJiffies to streamDecoder.startAtJiffies(), 3) Route playSilence to streamDecoder.playSilence(), 4) Route skipAhead to streamDecoder.skipAhead(). Files: AudioManager.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:56:39.739761-05:00","updated_at":"2025-12-01T21:09:28.079155-05:00","closed_at":"2025-12-01T21:09:28.079155-05:00","dependencies":[{"issue_id":"LMS_StreamTest-512","depends_on_id":"LMS_StreamTest-77b","type":"blocks","created_at":"2025-12-01T20:56:48.302861-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-5uz","title":"Phase 1: Implement Jiffies Epoch Tracking","description":"Add jiffiesEpoch and jiffiesOffsetList tracking to SlimProtoCoordinator. Update epoch on every STAT received with drift correction using offset list (max 8 entries). Files: SlimProtoCoordinator.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:32:50.494905-05:00","updated_at":"2025-12-01T20:36:42.225743-05:00","closed_at":"2025-12-01T20:36:42.225743-05:00"}
{"id":"LMS_StreamTest-6tc","title":"Wake On LAN support","description":"User requests Wake On LAN functionality to wake sleeping Lyrion server from the app.\n\nTechnical considerations:\n- iOS apps have network restrictions that may limit WOL packet broadcasting\n- May require local network permissions and user configuration\n- Need to discover and store server MAC addresses\n- Could integrate with existing server discovery system\n\nNote: Feasibility needs investigation - iOS networking limitations may prevent reliable WOL implementation.\n\nGitHub issue: #38\nAuthor: wiredcharlie\nOpened: Oct 18, 2025\n\nPriority: Low - Nice-to-have feature, technical feasibility uncertain","status":"open","priority":4,"issue_type":"feature","created_at":"2025-11-30T14:59:59.940071-05:00","updated_at":"2025-11-30T14:59:59.940071-05:00","external_ref":"gh-38"}
{"id":"LMS_StreamTest-77b","title":"Phase 7.4: Implement Buffer Skip Ahead for Push Streams","description":"Add skip ahead (consume buffer) to StreamDecoder. For drift correction when player is behind. Implementation: 1) Add skipAhead(duration:) method, 2) Calculate bytes to skip based on duration and sample rate, 3) Discard buffered data by not calling BASS_StreamPutData, 4) Track skipped bytes to maintain position. Files: StreamDecoder.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:56:39.600713-05:00","updated_at":"2025-12-01T21:07:43.327121-05:00","closed_at":"2025-12-01T21:07:43.327121-05:00","dependencies":[{"issue_id":"LMS_StreamTest-77b","depends_on_id":"LMS_StreamTest-ceb","type":"blocks","created_at":"2025-12-01T20:56:48.268047-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-87x","title":"Phase 4: Implement Sync Drift Corrections","description":"Handle strm 'p' (timed pause - play silence) and strm 'a' (skip ahead - consume buffer). Extract interval from replay_gain field. Files: SlimProtoCommandHandler.swift, AudioPlayer.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:32:50.836893-05:00","updated_at":"2025-12-01T20:48:13.745477-05:00","closed_at":"2025-12-01T20:48:13.745477-05:00","dependencies":[{"issue_id":"LMS_StreamTest-87x","depends_on_id":"LMS_StreamTest-owe","type":"blocks","created_at":"2025-12-01T20:33:02.957686-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-9f2","title":"-","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-30T14:44:06.051305-05:00","updated_at":"2025-11-30T14:44:06.051305-05:00"}
{"id":"LMS_StreamTest-9up","title":"Phase 6: Test and Verify Synchronization Implementation","description":"Test Phases 1, 2, 5 which work with push streams. Verify: 1) Jiffies epoch tracking logs, 2) strm u/p/a command parsing (not execution), 3) Sync group persistence. Document that Phases 3-4 need push stream implementation. This is TESTING ONLY - sync won't actually work until Phase 7 completes.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-01T20:55:20.595882-05:00","updated_at":"2025-12-01T20:56:17.462895-05:00"}
{"id":"LMS_StreamTest-9x6","title":"Multi-track FLAC files only play first track","description":"Multi-track FLAC files only play the first track. When browsing, all tracks show correctly, but:\n\n- Hitting play only plays first track\n- 'Play Next' does nothing - time display flashes at 0:01\n- Single-track FLAC files play fine\n- Other LMS clients (squeezelite) handle multi-track FLAC correctly\n\nEnvironment:\n- iOS version: 26.1\n- LyrPlay version: 1.6.2\n- User's local music library consists mostly of multi-track FLAC files\n\nThis appears to be a BASS/FLAC parsing issue where multi-track FLAC files aren't being handled properly in the audio pipeline.\n\nGitHub issue: #48\nAuthor: david2005it\nOpened: Nov 23, 2025\n\nPriority: High - affects core playback functionality for users with multi-track FLAC libraries","status":"open","priority":1,"issue_type":"bug","created_at":"2025-11-30T14:56:29.912656-05:00","updated_at":"2025-11-30T14:56:29.912656-05:00","external_ref":"gh-48"}
{"id":"LMS_StreamTest-bmh","title":"OGG \u0026 Opus transcode not working - always outputs MP3","description":"User cannot get OGG or Opus transcoding to work. Lyrion plugin is installed correctly (Docker dev version on Synology), but:\n\n- OGG and Opus transcode settings always result in MP3 output\n- FLAC transcode works correctly\n- User's source files are Apple Lossless (ALAC)\n- Tried both Lyrion dev and stable versions\n\nNeed to verify:\n1. LyrPlay app properly accepts and requests OGG/Opus formats\n2. BASS library can handle OGG/Opus decoding/playback\n3. Lyrion server transcode configuration for OGG/Opus from ALAC sources\n\nThis may be a format negotiation issue between LyrPlay and Lyrion, or BASS codec support limitation.\n\nGitHub issue: #41\nAuthor: Seb0101\nOpened: Nov 5, 2025\n\nPriority: High - Core transcoding functionality not working for OGG/Opus formats","status":"in_progress","priority":1,"issue_type":"bug","created_at":"2025-11-30T14:58:37.449093-05:00","updated_at":"2025-12-01T06:51:21.823443-05:00","external_ref":"gh-41"}
{"id":"LMS_StreamTest-c4i","title":"Phase 7.6: Test Push Stream Synchronization End-to-End","description":"Verify push stream sync works with real LMS server. Test: 1) Create sync group with 2+ players, 2) Verify synchronized start (strm u with jiffies), 3) Test drift corrections (strm p/a), 4) Verify gapless playback still works, 5) Check sync group persistence. Collect logs showing jiffies timing and sync accuracy. Files: Console logs, LMS server logs","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-01T20:56:39.88363-05:00","updated_at":"2025-12-01T20:56:39.88363-05:00","dependencies":[{"issue_id":"LMS_StreamTest-c4i","depends_on_id":"LMS_StreamTest-512","type":"blocks","created_at":"2025-12-01T20:56:48.346825-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-ceb","title":"Phase 7.3: Implement Silence Injection for Push Streams","description":"Add timed pause (play silence) to StreamDecoder. For drift correction when player is ahead. Implementation: 1) Add playSilence(duration:) method, 2) Generate silence bytes (zeros) for duration, 3) Use BASS_StreamPutData to inject silence, 4) Continue with normal playback after silence. Files: StreamDecoder.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:56:39.460396-05:00","updated_at":"2025-12-01T21:05:26.216546-05:00","closed_at":"2025-12-01T21:05:26.216546-05:00","dependencies":[{"issue_id":"LMS_StreamTest-ceb","depends_on_id":"LMS_StreamTest-db0","type":"blocks","created_at":"2025-12-01T20:56:48.234617-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-d98","title":"Fix reconnection position jumps - backward jumps and track skips on reconnect","description":"When LyrPlay loses server connection while playing from buffer and reconnects minutes later:\n1. Position jumps backward to disconnect time (user at 3:30, jumps to 1:30) \n2. Track skips forward to next track unexpectedly\n\nRoot cause: Server saves positionAtDisconnect when connection lost, client continues playing from buffer, but on reconnect server's playerReconnect() uses stale position causing backward jump.\n\nSolution: Block server's auto-resume and take full control of position restoration by:\n- Track playback state at disconnect moment with wasPlayingAtDisconnect flag\n- On reconnect, immediately send STOP to block server's auto-resume  \n- Query current position from AudioManager\n- Send playlist jump with current position (overrides server's stale position)\n- Resume playback\n\nImplementation requires 3 small changes to SlimProtoCoordinator.swift:\n1. Add wasPlayingAtDisconnect flag (~line 35)\n2. Capture state in slimProtoDidDisconnect() (~line 527) \n3. Override position in slimProtoDidConnect() (~line 514)\n\nLeverages existing infrastructure (AudioManager APIs, JSON-RPC commands, UserDefaults) with minimal code addition (~45 lines). Compatible with existing lock screen recovery - different triggers prevent conflicts.\n\nTesting scenarios: long disconnect while playing, paused during disconnect, quick reconnect, app backgrounded scenarios.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-11-30T22:05:59.439757-05:00","updated_at":"2025-11-30T22:06:06.94233-05:00"}
{"id":"LMS_StreamTest-db0","title":"Phase 7.2: Implement Delayed Start for Push Streams","description":"Add synchronized start capability to StreamDecoder. Similar to AudioPlayer.startAt() but for push streams. Implementation: 1) Add startAtJiffies() method to StreamDecoder, 2) Buffer data but don't call BASS_ChannelPlay until target time, 3) Monitor jiffies with timer (100ms), 4) Start playback when time reached. Files: StreamDecoder.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:56:39.315951-05:00","updated_at":"2025-12-01T21:03:53.874247-05:00","closed_at":"2025-12-01T21:03:53.874247-05:00","dependencies":[{"issue_id":"LMS_StreamTest-db0","depends_on_id":"LMS_StreamTest-1us","type":"blocks","created_at":"2025-12-01T20:56:48.199417-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-ea3","title":"Add authentication support for password-protected LMS servers","description":"Implement HTTP Basic Authentication for connecting to password-protected LMS servers.\n\n**Research Complete:**\nLMS uses standard HTTP Basic Auth headers (username:password base64 encoded) for all HTTP requests including audio streams. Server validates credentials in checkAuthorization() using SHA1 base64 password comparison.\n\n**Implementation Requirements:**\n1. Add username/password fields to SettingsManager for primary and backup servers (store securely in iOS Keychain)\n2. Generate Authorization header: 'Authorization: Basic base64(username:password)'\n3. Pass authentication header to BASS_StreamCreateURL via BASS_CONFIG_NET_AGENT or custom download procedure\n4. Add UI fields in settings for server credentials (secure text entry)\n5. Handle 401 Unauthorized responses gracefully with user feedback\n6. Test with both authenticated and non-authenticated servers\n\n**Files to Modify:**\n- SettingsManager.swift (add username/password storage with Keychain)\n- AudioPlayer.swift (add auth header to BASS_StreamCreateURL calls)\n- SettingsView components (add credential input fields)\n- SlimProtoCoordinator.swift (handle 401 responses)\n\n**Reference Code:**\n- slimserver/Slim/Web/HTTP.pm (checkAuthorization function)\n- squeezelite/slimproto.c (no auth in SlimProto protocol itself, only HTTP streams)","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-30T21:39:44.340738-05:00","updated_at":"2025-11-30T21:39:44.340738-05:00"}
{"id":"LMS_StreamTest-eiz","title":"Synchronization with other players failing","description":"# Player Synchronization Implementation\n\n## RESEARCH COMPLETE - How SlimProto Sync Works\n\n### Core Concept: Jiffies-Based Time Synchronization\nPlayers synchronize by agreeing on a common time base (\"jiffies epoch\") and starting playback at precise future timestamps.\n\n---\n\n## 1. Jiffies Epoch Tracking (Server ↔ Player Time Agreement)\n\n**What are jiffies?**\n- Player's local millisecond timer (gettime_ms())\n- Sent in every STAT packet to server\n- Server uses this to calculate player's time base\n\n**Jiffies Epoch Calculation** (Player.pm:932):\n```\njiffiesTime = jiffies / ticspersec\noffset = serverTimestamp - jiffiesTime\nepoch = offset (adjusted for drift)\n```\n\n**LyrPlay Implementation:**\n- Track jiffiesEpoch in SlimProtoCoordinator\n- Update epoch on every STAT received (like trackJiffiesEpoch)\n- Use offset list to handle clock drift correction\n- Current jiffies = gettime_ms()\n\n---\n\n## 2. Sync Group Formation\n\n**HELO Packet** - Advertise sync capability:\n```\ncapabilities += \",SyncgroupID=\u003csyncgroup_id\u003e\"\n```\n\n**serv Packet** - Server assigns sync group:\n- Contains 10-byte sync group ID\n- Store in SlimProtoCoordinator\n- Send in subsequent HELO reconnects\n\n**LyrPlay Status:** ✅ HELO sync capability already implemented\n\n---\n\n## 3. Synchronized Start (strm 'u' - Unpause)\n\n**Server Side** (Squeezebox2.pm:1098):\n```perl\n$client-\u003estream('u', { \n  'interval' =\u003e int(($startTime - $client-\u003ejiffiesEpoch()) * 1000) \n});\n```\n\n**Protocol** (Squeezebox.pm:1078):\n- strm command = 'u'\n- replay_gain field = jiffies timestamp (when to start)\n\n**Player Side** (output.c:99-109):\n```c\nif (output.state == OUTPUT_START_AT) {\n    u32_t now = gettime_ms();\n    if (now \u003e= output.start_at || output.start_at \u003e now + 10000) {\n        output.state = OUTPUT_RUNNING;\n    } else {\n        // Play silence until start_at time reached\n        u32_t delta_frames = (output.start_at - now) * sample_rate / 1000;\n        play_silence(delta_frames);\n    }\n}\n```\n\n**LyrPlay Implementation:**\n1. Parse strm 'u' command\n2. Extract jiffies from replay_gain field (network byte order)\n3. If jiffies == 0: start immediately (OUTPUT_RUNNING)\n4. If jiffies \u003e 0: enter OUTPUT_START_AT state\n5. **Play silence** until gettime_ms() \u003e= start_at\n6. Then switch to OUTPUT_RUNNING and play audio\n7. Send STMr (resume acknowledgment)\n\n---\n\n## 4. Sync Corrections (Drift Handling)\n\n**strm 'p' - Timed Pause** (Squeezebox2.pm:1114):\n```perl\n$client-\u003estream('p', { 'interval' =\u003e $milliseconds });\n```\n- Play silence for N milliseconds to slow down\n- Then resume playback\n- Corrects \"player ahead\" drift\n\n**strm 'a' - Skip Ahead** (Squeezebox2.pm:1122):\n```perl\n$client-\u003estream('a', { 'interval' =\u003e $milliseconds });\n```\n- Skip N milliseconds of audio (consume buffer without playing)\n- Corrects \"player behind\" drift\n\n**LyrPlay Implementation:**\n- strm 'p': Set pauseFramesRemaining, play silence\n- strm 'a': Skip frames in BASS buffer using BASS_ChannelSetPosition\n\n---\n\n## 5. STAT Packet Requirements\n\n**Critical Fields** (slimproto.c:186):\n```c\npackN(\u0026pkt.jiffies, now);  // Current player time (gettime_ms())\npackN(\u0026pkt.elapsed_milliseconds, ms_played);\npkt.server_timestamp = server_timestamp;  // Echo from strm 't'\n```\n\n**LyrPlay Status:** ✅ Already sending jiffies in STAT packets\n\n---\n\n## Implementation Plan for LyrPlay\n\n### Phase 1: Jiffies Epoch Tracking ⬜\n```swift\n// SlimProtoCoordinator\nprivate var jiffiesEpoch: TimeInterval = 0\nprivate var jiffiesOffsetList: [TimeInterval] = []\n\nfunc trackJiffiesEpoch(jiffies: UInt32, serverTimestamp: TimeInterval) {\n    let jiffiesTime = Double(jiffies) / 1000.0\n    let offset = serverTimestamp - jiffiesTime\n    \n    // Adjust epoch if better estimate or wrap-around\n    if offset \u003c jiffiesEpoch || offset - jiffiesEpoch \u003e 50 {\n        jiffiesEpoch = offset\n    }\n    \n    // Track drift for corrections\n    jiffiesOffsetList.insert(offset - jiffiesEpoch, at: 0)\n    if jiffiesOffsetList.count \u003e 8 { jiffiesOffsetList.removeLast() }\n}\n```\n\n### Phase 2: strm 'u' Unpause with Timing ⬜\n```swift\n// SlimProtoCommandHandler\ncase let strmData where strmData[0] == UInt8(ascii: \"u\"):\n    let replayGainBytes = strmData[12..\u003c16]\n    let jiffies = replayGainBytes.withUnsafeBytes { \n        $0.load(as: UInt32.self).bigEndian \n    }\n    \n    if jiffies == 0 {\n        audioPlayer?.resume()  // Start immediately\n    } else {\n        let startAt = TimeInterval(jiffies)\n        audioPlayer?.startAt(jiffies: startAt)  // New method\n    }\n    \n    sendSTAT(event: \"STMr\")\n```\n\n### Phase 3: OUTPUT_START_AT State ⬜\n```swift\n// AudioPlayer\nenum PlaybackState {\n    case stopped, buffering, running, startAt(jiffies: TimeInterval)\n}\n\nfunc startAt(jiffies: TimeInterval) {\n    self.playbackState = .startAt(jiffies: jiffies)\n    \n    // In audio callback/timer:\n    if case .startAt(let targetJiffies) = playbackState {\n        let now = gettime_ms()\n        if now \u003e= targetJiffies {\n            playbackState = .running\n            BASS_ChannelPlay(currentStream, 0)\n        } else {\n            // Keep buffering, don't play yet\n            // or output silence if needed\n        }\n    }\n}\n```\n\n### Phase 4: Sync Corrections ⬜\n```swift\n// strm 'p' - timed pause\ncase let strmData where strmData[0] == UInt8(ascii: \"p\"):\n    let intervalMs = // extract from replay_gain field\n    audioPlayer?.pauseForInterval(milliseconds: intervalMs)\n\n// strm 'a' - skip ahead  \ncase let strmData where strmData[0] == UInt8(ascii: \"a\"):\n    let intervalMs = // extract from replay_gain field\n    audioPlayer?.skipAhead(milliseconds: intervalMs)\n```\n\n### Phase 5: Sync Group Persistence ⬜\n- Store syncGroupID in UserDefaults\n- Include in HELO on reconnect\n- Parse from serv packet (10-byte field)\n\n---\n\n## Testing Strategy\n\n1. **Epoch tracking**: Log jiffies drift over time, verify convergence\n2. **Basic sync**: Pair with squeezelite, verify synchronized start\n3. **Drift correction**: Run 30+ minutes, verify strm 'p'/'a' commands handled\n4. **Reconnection**: Verify sync group persists across app restarts\n5. **Multi-room**: Test with 3+ players in sync group\n\n---\n\n## Files to Modify\n\n1. **SlimProtoCoordinator.swift**\n   - Add jiffiesEpoch tracking\n   - Parse strm 'u' with timing\n   - Handle sync group from serv packet\n\n2. **SlimProtoCommandHandler.swift**\n   - Route strm 'p' and strm 'a' commands\n   - Extract timing from replay_gain field\n\n3. **AudioPlayer.swift**\n   - Implement OUTPUT_START_AT state\n   - Add startAt(jiffies:) method\n   - Implement pauseForInterval() and skipAhead()\n\n4. **SettingsManager.swift**\n   - Store syncGroupID persistence\n\n---\n\n## Key References\n\n- squeezelite/output.c:99-109 (OUTPUT_START_AT implementation)\n- slimserver/Slim/Player/Squeezebox2.pm:1093-1124 (sync commands)\n- slimserver/Slim/Player/Player.pm:932-996 (jiffies epoch tracking)\n- squeezelite/slimproto.c:332-342 (strm 'u' handling)\n\nPriority: P1 - Core multi-room functionality\nStatus: Ready to implement with research complete","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-11-30T15:01:29.089852-05:00","updated_at":"2025-12-01T20:53:31.133846-05:00","closed_at":"2025-12-01T20:53:31.133846-05:00","external_ref":"gh-36","dependencies":[{"issue_id":"LMS_StreamTest-eiz","depends_on_id":"LMS_StreamTest-5uz","type":"parent-child","created_at":"2025-12-01T20:33:02.642248-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-eiz","depends_on_id":"LMS_StreamTest-244","type":"parent-child","created_at":"2025-12-01T20:33:02.683641-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-eiz","depends_on_id":"LMS_StreamTest-owe","type":"parent-child","created_at":"2025-12-01T20:33:02.721711-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-eiz","depends_on_id":"LMS_StreamTest-87x","type":"parent-child","created_at":"2025-12-01T20:33:02.755931-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-eiz","depends_on_id":"LMS_StreamTest-139","type":"parent-child","created_at":"2025-12-01T20:33:02.79212-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-jr2","title":"commit current work to new branch","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-30T14:44:33.672652-05:00","updated_at":"2025-11-30T14:49:57.59035-05:00","closed_at":"2025-11-30T14:49:57.59035-05:00"}
{"id":"LMS_StreamTest-mx0","title":"White text on light grey background - poor readability","description":"Cosmetic UI issue with poor text contrast. White text on light grey background is difficult to read.\n\nUser suggests changing text color to blue for better visibility.\n\nThis appears to be a SwiftUI color scheme issue where text colors don't adapt properly to certain background elements, causing accessibility and usability problems.\n\nGitHub issue: #47\nAuthor: ChristianNoc  \nOpened: Nov 22, 2025\n\nPriority: Low - Cosmetic issue but affects user experience and accessibility\n\nFiles likely affected: SwiftUI views with text styling, color scheme definitions","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-11-30T14:57:08.992482-05:00","updated_at":"2025-11-30T19:25:14.935952-05:00","closed_at":"2025-11-30T19:25:14.935952-05:00","external_ref":"gh-47"}
{"id":"LMS_StreamTest-okt","title":"Server setup not working when using http","description":"During initial setup, HTTP connection fails with 'App Transport Security Policy requires a secure transport' error. iOS ATS blocks HTTP connections, preventing setup with HTTP-only LMS servers. Need to configure ATS exceptions or provide HTTPS option.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-11-30T19:32:22.015391-05:00","updated_at":"2025-11-30T19:32:22.015391-05:00"}
{"id":"LMS_StreamTest-owe","title":"Phase 3: Implement OUTPUT_START_AT State","description":"Add .startAt(jiffies:) case to PlaybackState enum. Implement delayed playback start logic - buffer but don't play until gettime_ms() \u003e= targetJiffies. Files: AudioPlayer.swift","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-01T20:32:50.720986-05:00","updated_at":"2025-12-01T20:44:32.930308-05:00","closed_at":"2025-12-01T20:44:32.930308-05:00","dependencies":[{"issue_id":"LMS_StreamTest-owe","depends_on_id":"LMS_StreamTest-244","type":"blocks","created_at":"2025-12-01T20:33:02.917078-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-p6j","title":"change lossless with seeking (WAV) to just Lossless (WAV) in settings menu","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-30T19:26:50.742806-05:00","updated_at":"2025-11-30T19:27:20.028045-05:00","closed_at":"2025-11-30T19:27:20.028045-05:00"}
{"id":"LMS_StreamTest-q0t","title":"Multiple app icon styles/themes for customization","description":"User requests multiple app icon styles and color schemes to choose from, similar to Git app's icon variations.\n\nUser specifically interested in retro wave/karaoke fantasy style to match homescreen aesthetics.\n\nImplementation considerations:\n- iOS supports multiple app icon variants through asset catalogs\n- Need to design and create alternative icon sets\n- Could offer themed icon packs (retro, modern, minimal, etc.)\n- User selection interface in app settings\n\nMonetization Plan Reference:\nSee /docs/MONETIZATION_PLAN.md for complete monetization strategy:\n- Custom App Icons planned as Tier 1 feature at .99\n- Ready to implement using UIApplication.setAlternateIconName()\n- Part of LyrPlay Pro bundle (.99) or individual purchase\n- BASS Shareware license (€125) required for IAP implementation\n- Break-even at ~68 icon pack sales or ~20 Pro bundle sales\n\nGitHub issue: #34\nAuthor: bungh0l10\nOpened: Sep 26, 2025\n\nPriority: Low - Cosmetic enhancement but improves user personalization","status":"open","priority":1,"issue_type":"feature","created_at":"2025-11-30T15:01:50.101228-05:00","updated_at":"2025-11-30T22:23:55.663125-05:00","external_ref":"gh-34"}
{"id":"LMS_StreamTest-q0t.1","title":"Research iOS alternate icon implementation requirements and create asset catalog structure","description":"","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-11-30T22:28:12.69873-05:00","updated_at":"2025-11-30T22:30:24.013803-05:00","dependencies":[{"issue_id":"LMS_StreamTest-q0t.1","depends_on_id":"LMS_StreamTest-q0t","type":"parent-child","created_at":"2025-11-30T22:28:12.699022-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-q0t.2","title":"Design retro wave/karaoke fantasy app icon set with all required iOS sizes","description":"Create themed app icon sets including retro wave (80s synthwave aesthetic) and karaoke fantasy (neon lights, microphone elements). Need all iOS sizes from 16x16 to 1024x1024 with @2x/@3x variants for Retina displays.","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-30T22:28:17.112389-05:00","updated_at":"2025-11-30T22:28:17.112389-05:00","dependencies":[{"issue_id":"LMS_StreamTest-q0t.2","depends_on_id":"LMS_StreamTest-q0t","type":"parent-child","created_at":"2025-11-30T22:28:17.112673-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-q0t.3","title":"Add app icon selection UI to SettingsManager and SettingsView","description":"Extend SettingsManager.swift with AppIconTheme enum and selectedAppIcon property. Add new section in SettingsView.swift for icon selection with preview grid, lock indicators for premium themes, and IAP integration points.","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-30T22:28:21.292273-05:00","updated_at":"2025-11-30T22:28:21.292273-05:00","dependencies":[{"issue_id":"LMS_StreamTest-q0t.3","depends_on_id":"LMS_StreamTest-q0t","type":"parent-child","created_at":"2025-11-30T22:28:21.292585-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-q0t.3","depends_on_id":"LMS_StreamTest-q0t.1","type":"blocks","created_at":"2025-11-30T22:28:37.566279-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-q0t.4","title":"Implement UIApplication.setAlternateIconName functionality with proper error handling","description":"Create AppIconManager.swift class with setAlternateIcon() method using UIApplication.shared.setAlternateIconName(). Include error handling for invalid icons, IAP validation before switching, and UserDefaults persistence for selection.","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-30T22:28:25.292121-05:00","updated_at":"2025-11-30T22:28:25.292121-05:00","dependencies":[{"issue_id":"LMS_StreamTest-q0t.4","depends_on_id":"LMS_StreamTest-q0t","type":"parent-child","created_at":"2025-11-30T22:28:25.292443-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-q0t.4","depends_on_id":"LMS_StreamTest-q0t.1","type":"blocks","created_at":"2025-11-30T22:28:41.676746-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-q0t.4","depends_on_id":"LMS_StreamTest-q0t.3","type":"blocks","created_at":"2025-11-30T22:28:55.792385-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-q0t.5","title":"Research and implement StoreKit IAP for app icon monetization (/bin/zsh.99)","description":"Implement StoreKit 2 integration with IAPManager.swift, AppIconProduct.swift, and PurchaseView.swift. Create non-consumable product 'com.lyrplay.appicons.premium' at Tier 1 pricing (/bin/zsh.99). Include receipt validation and restore purchases functionality.","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-30T22:28:29.605592-05:00","updated_at":"2025-11-30T22:28:29.605592-05:00","dependencies":[{"issue_id":"LMS_StreamTest-q0t.5","depends_on_id":"LMS_StreamTest-q0t","type":"parent-child","created_at":"2025-11-30T22:28:29.605939-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-q0t.5","depends_on_id":"LMS_StreamTest-q0t.4","type":"blocks","created_at":"2025-11-30T22:28:59.068928-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-q0t.6","title":"Test icon switching across different iOS devices and versions","description":"Comprehensive testing of icon switching functionality on different iOS versions (15.6+), device types (iPhone/iPad), and scenarios (app restart, background/foreground, IAP failures). Include UI polish for smooth transitions and loading states.","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-30T22:28:33.689457-05:00","updated_at":"2025-11-30T22:28:33.689457-05:00","dependencies":[{"issue_id":"LMS_StreamTest-q0t.6","depends_on_id":"LMS_StreamTest-q0t","type":"parent-child","created_at":"2025-11-30T22:28:33.689772-05:00","created_by":"daemon"},{"issue_id":"LMS_StreamTest-q0t.6","depends_on_id":"LMS_StreamTest-q0t.5","type":"blocks","created_at":"2025-11-30T22:29:03.526123-05:00","created_by":"daemon"}]}
{"id":"LMS_StreamTest-ry8","title":"Gapless boundary drift and metadata desync on track transitions","description":"INTERMITTENT gapless boundary prediction and metadata sync issues occur during track transitions on PUSH STREAM architecture.\n\nIMPORTANT: \n- Specific to BASS PUSH STREAM architecture (not URL streaming)\n- NOT format-specific - occurs on opus→opus, FLAC→FLAC, opus→FLAC, any combination\n- INTERMITTENT - does not happen on every track transition\n- Suggests timing-dependent issue or race condition in push stream boundary handling\n\nRoot cause hypothesis: Boundary calculation and metadata update timing issues in BASS push stream gapless playback system, likely involving race conditions between push stream sync callbacks and UI updates.\n\nCarPlay/Lock Screen Manifestations:\n\nISSUE 1: Metadata Desync at Track Transition\n- iOS device interface: Shows correct Track 2 metadata after transition\n- Server interface: Shows correct Track 2 metadata\n- CarPlay: Shows old Track 1 metadata with timer reset\n- Result: CarPlay and iOS out of sync during track transitions\n- Frequency: Intermittent\n\nISSUE 2: Premature Metadata Update with Timer Reset Loop\n- Observed on: CarPlay (possibly lock screen too - TBD)\n- Sequence:\n  1. Track 1 audio playing normally\n  2. Track 2 metadata suddenly appears on interface\n  3. Track 1 audio CONTINUES playing (audio doesn't match metadata)\n  4. Timer gets stuck resetting: 0-1s, 0-2s, 0-1s, 0-2s...\n  5. Timer reset loop continues UNTIL Track 2 audio actually starts\n- Frequency: Intermittent\n- Root cause hypothesis: Metadata updated too early based on inaccurate push stream boundary prediction or race condition\n\nOriginal technical observations (from push streams):\n- SimpleTracker jumps backwards (-155.81s advancement)\n- Prediction errors up to ±16 seconds\n- STMs sent early (while previous track still playing) or late (already into next track)\n- 131-second buffer gaps between write/read positions\n- Write-Read gap: 50636840 bytes (131.867 seconds ahead)\n- Track boundary reached at 42.33s but predicted for 41.49s\n\nFiles to investigate:\n- AudioStreamDecoder.swift (BASS push stream boundary calculation logic)\n- AudioPlayer.swift (BASS sync callbacks and push stream management)\n- NowPlayingManager.swift (metadata sync timing)\n- PlaybackSessionController.swift (remote command center updates)\n- CarPlaySceneDelegate.swift (CarPlay template updates)\n- SimpleTimeTracker.swift (position tracking with push streams)\n\nPush stream specific concerns:\n- BASS_SYNC_END callbacks timing\n- Write position vs read position tracking in push streams\n- Boundary prediction based on bytes written vs bytes played\n- Race between BASS sync callbacks and metadata updates\n- Push stream buffer state during track transitions\n\nPossible race conditions:\n- BASS sync callback thread vs main thread metadata updates\n- Push stream boundary detection vs UI update timing\n- CarPlay template updates vs main app updates\n- Multiple BASS sync callbacks firing in rapid succession\n\nNext steps:\n- Capture debug logs during track transitions (successful AND failed cases)\n- Log BASS sync callback timing and thread context\n- Compare timing sequences between working and broken transitions\n- Analyze coordination between BASS push stream callbacks and UI metadata updates\n- Check write/read position tracking during transitions\n- Look for race conditions in metadata propagation paths\n\nPriority: High - affects gapless playback reliability AND CarPlay/lock screen user experience","status":"open","priority":1,"issue_type":"bug","created_at":"2025-11-30T14:54:06.219403-05:00","updated_at":"2025-12-02T21:20:15.977621-05:00"}
{"id":"LMS_StreamTest-w0e","title":"Test beads setup","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-30T15:29:47.309598-05:00","updated_at":"2025-11-30T15:30:17.415057-05:00","closed_at":"2025-11-30T15:30:17.415057-05:00"}
{"id":"LMS_StreamTest-xxe","title":"Apple Watch integration for Lyrion player control","description":"User requests Apple Watch app to control Lyrion players. Current iPeng app has Watch support but can't switch players on watch, making it limited.\n\nUser willing to contribute PR as learning opportunity for Swift development.\n\nKey requirements:\n- Control Lyrion players from Apple Watch\n- Player switching capability on watch (unlike iPeng)\n- Basic playback controls (play/pause/skip)\n- Integration with existing LyrPlay architecture\n\nGitHub issue: #51\nAuthor: magicus\nOpened: Nov 30, 2025\n\nNote: Specific feature details to be defined, but core request is Watch app for player control.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-30T14:55:47.852334-05:00","updated_at":"2025-11-30T14:55:47.852334-05:00","external_ref":"gh-51"}
